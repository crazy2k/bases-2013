\section{Resultados}

\subsection{Comparaci\'on con LRU y MRU}

\textsl{En esta subsecci\'on expondremos algunas de las ventajas y
desventajas del algoritmo de touch-count frente a los de MRU y LRU,
en distintas situaciones.}

\vspace*{0.5cm}

Como fue explicado, el algoritmo de touch-count optimiza el algoritmo
de reemplazo de p\'aginas de LRU para aquellas situaciones en las cuales
se pod\'ia vaciar el buffer cache por completo.
Esta es una situaci\'on a evitar porque podr\'ian perderse los bloques
que se necesitan con m\'as frecuencia, y es deseable que los mismos
permanezcan en cache, es decir que est\'en los bloques que realmente
se necesitan.

\vspace*{0.3cm}

En una situaci\'on en la cual un conjunto de bloques sean necesitados
de forma constante (por un tiempo), el algoritmo tambi\'en se comporta
de forma adecuada. 
Dichos bloques pasar\'an a ubicarse en la \textbf{hot region}, y 
continuar\'an incrementando su contador con el fin de permanecer
en cache.

\vspace*{0.3cm}

Sin embargo, el algoritmo de touch count se comporta peor que MRU
en el caso en que se usan muchos bloques diferentes y luego se hace 
referencia a alguno que fue usado con anterioridad (no recientemente).

En MRU, los bloques viejos permanecen en cache, por lo que estar\'an
disponibles para ser r\'apidamente accedidos.
Por otro lado, tanto en touch-count como en LRU, estos bloques viejos
saldran de cache cuando antes (en el caso de touch-count por tener un
valor de contador bajo).

\subsection{Conclusiones}

\textsl{En esta subsecci\'on presentaremos nuestras observaciones
sobre las comparaciones explicadas en la subsecci\'on anterior.}

\vspace*{0.5cm}

Concluimos que en la mayor\'ia de los casos, touch-count tiene una
eficiencia superior a la de LRU y MRU.
Sin embargo, existen ciertos casos bordes que mencionamos en los cuales
LRU y/o MRU se comportan mejor.

\vspace*{0.3cm}

Aunque la implementaci\'on del algoritmo de touch-count sea mucho
m\'as compleja que la de los otros, creemos que vale la pena por los
beneficios que trae.




