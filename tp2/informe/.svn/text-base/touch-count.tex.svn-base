\section{Algoritmo de Touch Count}

\textsl{En esta secci\'on se presentar\'a el algoritmo de touch-count,
dando primero un breve resumen, luego un contexto y por
\'ultimo exponiendo una explicaci\'on.}

\subsection{Resumen}

\textsl{En esta subsecci\'on se dar\'a un breve resumen del 
funcionamiento general del algoritmo de touch-count.}

\vspace*{0.3cm}

El algoritmo de touchcount fue introducido en Oracle 8i, para
resolver las alteraciones del cache producidas por scans muy largos.

\vspace*{0.3cm}

Como en muchas estrategias de reemplazo de p\'aginas, se mantiene
una lista LRU, con las p\'aginas ordenadas seg\'un su frecuencia
de uso.
En un extremo est\'an las m\'as frecuentemente usadas (extremo MRU),
mientras que en el otro est\'an las menos frecuentemente usadas
(extremo LRU).

\vspace*{0.3cm}

Se hace que los bloquen ganen su derecho a estar y permanecer
en el extremo MRU de la lista LRU.
Es muy deseable estar en ese extremo para no ser desalojado.

\vspace*{0.3cm}

Se introduce el concepto de \textsl{touch-count}, donde cada buffer
tiene un contador.
Cuando un buffer es tocado, este contador se incrementa.
Oracle trata de que este contador se incremente solo una vez cada
3 segundos
(para que no se incremente de m\'as).

\vspace*{0.3cm}

El mecanismo mediante el cual los buffers se van moviendo en la
lista LRU sigue las siguientes reglas

\begin{itemize}
    \item
            Un nuevo buffer se ubica en la posici\'on 
            \texttt{\_db\_percent\_hot\_default}
            de la lista LRU.
            Esta constante establece d\'onde se encuentra la mitad,
            que deja hacia un lado los buffers que se consideran que
            son de alto uso (\textbf{hot region}), y 
            del otro los de bajo uso (\textbf{cold region}).
            
    \item
            Cuando el valor de touch-count de un buffer es mayor a 
            \texttt{\_db\_aging\_hot\_criteria} (generalmente 2), 
            se mueve ese bloque al extremo MRU de la lista. 
        %
        %Server process can move it while looking for a free buffer or
        %DBWR can move it while looking for the dirty blocks
        %
    %\item
            Una vez que un buffer es desplazado al extremo MRU, su
            contador de touch-count es reseteado a cero.

    \item
            Si un buffer en el extremo MRU no es usado nuevamente, se
            mueve al extremo LRU.
            En este caso, un buffer en la mitad de la lista pasar\'a
            de la \textbf{cold region} a la \textbf{hot region}.
            El valor de touch count de ese buffer se establece en 1.
\end{itemize}


%\subsection{Introducci\'on}
\newpage
\subsection{Contexto}

\textsl{En esta subsecci\'on se aclarar\'an los problemas existentes 
con los algoritmos anteriores (al de touch-count) de reemplazo de 
p\'aginas.}

\vspace*{0.5cm}

Antes de la creaci\'on del algoritmo de touch count, Oracle ten\'ia
un algoritmo presupon\'ia la existencia de buffers pequeños 
(lo cual ten\'ia sentido por la \'epoca en la que se desarroll\'o).
Con el avance del tiempo, esta suposici\'on de que los buffers eran
pequeños dej\'o de ser cierta, y el algoritmo se torn\'o obsoleto.

\vspace*{0.3cm}

Un problema que exist\'ia era en el caso de realizar un full-table 
scan, ya que cada bloque de la tabla era colocado en cache, removiendo
los bloques existentes, entre los cuales se encontraban los m\'as
utilizados. Esto destru\'ia toda optimizaci\'on posible sobre el
buffer de bloques. 

\vspace*{0.3cm}

Por ejemplo, si la tabla de que cual se le\'ia ten\'ia 600 bloques, y 
en cache exist\'ian 500 bloques, se hac\'ia una limpieza total de 
cache, ya que todos los bloques existentes previamente en cache, eran
removidos para hacer lugar a los de la tabla.
Esto ocurr\'ia en todos los casos en los que se realizara un full-table
scan, a\'un cuando los bloques fueran le\'idos solamente una vez.

\vspace*{0.3cm}

Para atacar este problema, se implement\'o un algoritmo de LRU
modificado, que posicionaba los bloques de un full-table scan en el
extremo LRU de la lista LRU (para que fueran descartados primero).
Adem\'as s\'olo se permit\'ia que una cantidad limitada de estos
bloques ocupara el buffer, amortiguando la p\'erdida de bloques
existentes.

\vspace*{0.3cm}

Sin embargo, exist\'ia otro problema, esta vez con los index range 
scans de gran tamaño.
S\'olo soportaba full-table scans y no index scans. 
%Una soluci\'on temprana (para salir del apuro), fue usar m\'ultiples
%buffer pools.
%Sin embargo, esto no es deseable, y esta 

\vspace*{0.3cm}

Para mantener la eficiencia en las operaciones, es necesario contar con
un algoritmo que sea r\'apido, y flexible.
Deber\'a hacer que los buffers se ganen el derecho de mantenerse en 
cache.

\newpage
\subsection{Funcionamiento}

%El algoritmo touch count implementa una forma de que cada bloque no solo se gane su lugar en el buffer caché sino también a permanecer allí.

%Parte del problema que intenta atacar el nuevo algoritmo es el 
%incremento considerable del tamaño de este buffer.
%Sin embargo, este cambio no fue suficiente, era necesario tambi\'en 
%tener un nivel de eficiencia elevado.

Cada buffer tiene asignado un contador (touch-count).
Cada vez que un bloque es tocado, el contador es incrementado.
El valor de este contador representa la ``popularidad'' de cada bloque.

\vspace*{0.3cm}

Existen dos \'areas definidas, el \'area de alto uso (\textbf{hot}), y 
la de bajo uso (\textbf{cold}).
Todos los buffers en la \textbf{hot region} son denominamos 
\textbf{hot buffers}, y los pertenecientes a la \textbf{cold region},
\textbf{cold buffers}.

\vspace*{0.3cm}
%\newpage
Existe un marcador de midpoint entre las dos regiones.
Este se va moviendo para asegurar una cantidad apropiada de buffers
en la \textbf{hot region} y \textbf{cold region}.
Por default, la divisi\'on es a la mitad.

\vspace*{0.3cm}

Cuando un proceso del servidor lee un bloque de disco, y lo coloca en
el buffer cache, dicho buffer es ubicado en el medio de la cadena, 
es decir entre las hoy y cold regions.

Esta acci\'on es conocida como midpoint insertion.
Es importante notar que el bloque cargado no se considera como el
primero de los m\'as recientemente usados, sino que deber\'a ganarse su
lugar incrementando su contador.

\vspace*{0.3cm}

En teor\'ia, cada vez que un bloque es tocado por el motivo que sea,
su contador es incrementado.
Sin embargo, en la pr\'actica esto no ocurre, ya que habr\'a ocasiones
en las cuales un bloque tenga un pico de intere\'es y luego no sea 
necesitado por un tiempo.

\vspace*{0.3cm}

Para atacar este problema, Oracle permite que este contador sea
incrementado a lo sumo cada tres segundos (este valor es configurable
seg\'un las necesidades del usuario).
Es decir, que no se incrementar\'a cada vez que sea tocado, si esto 
ocurre muy seguido (aunque ocurra m\'as de una vez en 3 segundos).

\vspace*{0.3cm}

Cuando un proceso del servidor busca buffers libres para colocar 
un bloque en cache, debe buscar un buffer cuyo contenido no difiera 
con el correspondiente en disco. Si difiere, el buffer es denominado
``dirty''.

Si en la b\'usqueda de bloques, se encuentra alguno cuyo contador es
mayor a dos, se mueve dicho bloque al extremo LRU de la lista y se
setea el contador en 0. El contador de dicho bloque deber\'a ser
incrementado en el corto plazo para no ser sacado.

\vspace*{0.3cm}

Cuando un bloque pasa de la \textbf{cold region} a la 
\textbf{hot region}, su contador ser\'a reseteado a uno.
Como en el caso anterior, el contador de dicho bloque deber\'a ser
incrementado en el corto plazo para no ser sacado.
