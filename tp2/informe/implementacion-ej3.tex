\section{Detalles de Implementaci\'on - Ejercicio 3}

La implementación de este ejercicio abarca varias clases, 
% el fin
% es lograr tener un buffer manager que use múltiples pools.
se muestran a continuación las clases que agregamos y modificamos.

\vspace*{0.2cm}

La implementación final del buffer con múltiples pools está realizada 
en la clase \newline
\texttt{MultipleBufferPool}, ubicada en
\texttt{\small core/components/bufferManager/bufferPool/pools/multiple}.

\vspace*{0.2cm}

\noindent
El test de unidad se encuentra en 
\texttt{\small tests/components/bufferManager/bufferPool/pools/multiple}.


\subsection{TableDescriptor}

Agregamos un campo tableBuffer, que es un String representando
el nombre del bufferPool al cual la tabla está asociada.

\vspace*{0.3cm}

Al construirse un nuevo \texttt{TableDescriptor}, si no se
provee dicho valor de tableBuffer, se toma como ``Default''

\vspace*{-0.2cm}
\begin{verbatimtab}[4]
public class TableDescriptor
{
	private TableId tableId;
	private String tableName;
	private String tablePath;	
	private String tableBuffer;

	...

	public TableDescriptor(TableId tableId, String tableName, String tablePath)
	{
		this(tableId, tableName, tablePath, "Default");
	}
}
\end{verbatimtab}

% -----------------------------------------------------------------------------

\subsection{PoolDescriptor}

Teniendo en cuenta la idea de la clase \texttt{TableDescriptor},
creamos la clase \texttt{PoolDescriptor}, que almacena el 
nombre y el tamaño de un pool.

\vspace*{-0.2cm}
\begin{verbatimtab}[4]
public class PoolDescriptor
{
	private String name;
	private Integer size;

	...
}
\end{verbatimtab}

% -----------------------------------------------------------------------------

\newpage

\subsection{Catalog}

Agregamos una lista de \texttt{PoolDescriptor} a la ya existente lista 
de \texttt{TableDescriptor}.
Agregamos un método que, dado el nombre de un Pool devuelve su tamaño, 
buscándolo en la lista \texttt{poolDesciptors}.

\vspace*{0.5cm}

Tener la lista \texttt{poolDescriptors} permite que se puedan tener
todos los buffers que se desee, diciendo para cada uno el nombre y 
el tamaño. Esto hace que la implementación sea configurable y
se tenga en cuenta la existencia de otros buffer más allá de los
propuestos por Oracle.

\begin{verbatimtab}[4]
public class Catalog
{
	private List<PoolDescriptor> poolDescriptors;
	private List<TableDescriptor> tableDescriptors;	

	....

	public Integer getSizeOfPool(String name) throws Exception 
	{
		for (PoolDescriptor p:poolDescriptors)
		{
			if (p.getName() == name)
			{
				return p.getSize();
			}
		}
		
		throw new Exception("Name does not exists");
	}
}
\end{verbatimtab}

% -----------------------------------------------------------------------------

\subsection{MultipleBufferPool}

Para implementar múltiples buffers, tenemos un 

\begin{verbatimtab}[4]
public class MultipleBufferPool implements BufferPool
{
	private Map<TableId, SingleBufferPool> tableMap;

	...

	public MultipleBufferPool(Catalog c)
	{
		Map<String, SingleBufferPool> bufferPools;
		bufferPools = new HashMap<String, SingleBufferPool>();
		
		for (PoolDescriptor p:c.getPoolDescriptors())
		{
			SingleBufferPool buf = new SingleBufferPool(p.getSize());
			bufferPools.put(p.getName(), buf);
		}
		
		tableMap = new HashMap<TableId, SingleBufferPool>();
		
		for (TableDescriptor t:c.getTableDescriptors())
		{
			tableMap.put(t.getTableId(), bufferPools.get(t.getTableBuffer()));
		}
	}
}
\end{verbatimtab}